{% extends "base.html" %}

{% block title %}LightRAG - Knowledge Assistant{% endblock %}

{% block body_class %}main-app{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="/static/css/main.css">
{% endblock %}

{% block content %}
<div class="app-container">
    <!-- Header -->
    <header class="app-header">
        <div class="app-logo">LightRAG</div>
        
        <div class="status-indicator">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Ready</span>
        </div>
        
        <div class="user-profile">
            <!-- Emergency logout button for debugging -->
            <button onclick="window.AuthManager.logout()" style="margin-right: 10px; padding: 5px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Logout</button>
            
            <div class="profile-dropdown">
                <button class="profile-button" id="profileButton">
                    <div class="profile-avatar" id="profileAvatar">U</div>
                    <span id="profileName">User</span>
                    <span>‚ñº</span>
                </button>
                <div class="dropdown-content" id="profileDropdown">
                    <a href="#" class="dropdown-item" id="profileLink">Profile</a>
                    <a href="#" class="dropdown-item" id="logoutLink">Logout</a>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="app-main">
        <!-- Left Column - Document Management -->
        <div class="left-column">
            <!-- Upload Section -->
            <section class="upload-section">
                <button class="upload-button" id="uploadButton">
                    Upload Document
                </button>
                
                <div class="drop-zone" id="dropZone">
                    <div class="drop-zone-content">
                        <div class="drop-zone-icon">üìÅ</div>
                        <p>Drag & drop files here</p>
                        <p class="text-xs text-muted">PDF, DOCX, TXT, MD ‚Ä¢ Max 5MB ‚Ä¢ Up to 5 files</p>
                    </div>
                </div>
                
                <div class="upload-progress" id="uploadProgress" style="display: none;">
                    <div class="text-sm mb-2">Uploading...</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                </div>
                
                <input type="file" id="fileInput" multiple accept=".pdf,.docx,.txt,.md" style="display: none;">
            </section>

            <!-- Documents List -->
            <section class="documents-section">
                <div class="section-header">
                    <h3 class="section-title">Documents</h3>
                    <button class="btn btn-sm btn-ghost" id="refreshDocuments">Refresh</button>
                </div>
                
                <div class="documents-list" id="documentsList">
                </div>
            </section>

            <!-- Entity Viewer -->
            <section class="entity-viewer">
                <div class="section-header">
                    <h3 class="section-title">Knowledge Graph</h3>
                    <button class="btn btn-sm btn-ghost" id="refreshEntities">Refresh</button>
                </div>
                
                <div class="tabs">
                    <button class="tab active" data-tab="entities">Entities</button>
                    <button class="tab" data-tab="graph">Graph</button>
                    <button class="tab" data-tab="relationships">Relations</button>
                </div>
                
                <div class="tab-content" id="tabContent">
                    <div class="tab-pane active" id="entitiesTab">
                        <div class="empty-state">
                            <div class="empty-state-icon">üîç</div>
                            <div class="empty-state-text">No entities extracted yet.</div>
                        </div>
                    </div>
                    <div class="tab-pane" id="graphTab">
                        <div class="empty-state">
                            <div class="empty-state-icon">üï∏Ô∏è</div>
                            <div class="empty-state-text">Knowledge graph will appear here.</div>
                        </div>
                    </div>
                    <div class="tab-pane" id="relationshipsTab">
                        <div class="empty-state">
                            <div class="empty-state-icon">üîó</div>
                            <div class="empty-state-text">No relationships found yet.</div>
                        </div>
                    </div>
                </div>
            </section>
        </div>

        <!-- Right Column - Chat Interface -->
        <div class="right-column">
            <!-- Chat Section -->
            <section class="chat-section">
                <div class="section-header">
                    <h3 class="section-title">Chat</h3>
                    <button class="btn btn-sm btn-ghost" id="clearChat">Clear</button>
                </div>
                
                <div class="chat-window" id="chatWindow">
                    <div class="empty-state">
                        <div class="empty-state-icon">üí¨</div>
                        <div class="empty-state-text">Start a conversation by asking a question about your documents.</div>
                    </div>
                </div>
                
                <div class="chat-input-area">
                    <textarea 
                        class="chat-input" 
                        id="messageInput" 
                        placeholder="Ask a question about your documents..."
                        rows="1"
                    ></textarea>
                    
                    <div class="chat-controls">
                        <label class="rag-toggle">
                            <input type="checkbox" id="useRag" checked>
                            <span>Use RAG</span>
                        </label>
                        <button class="send-button" id="sendButton">
                            <span>‚ñ∂</span>
                        </button>
                    </div>
                </div>
            </section>

            <!-- Thinking Panel -->
            <section class="thinking-panel">
                <div class="section-header">
                    <h3 class="section-title">Thinking Process</h3>
                    <div class="tabs">
                        <button class="tab active" data-tab="context">Context</button>
                        <button class="tab" data-tab="entities-match">Entities</button>
                        <button class="tab" data-tab="reasoning">Reasoning</button>
                    </div>
                </div>
                
                <div class="thinking-content" id="thinkingContent">
                    <div class="tab-pane active" id="contextTab">
                        <div class="empty-state">
                            <div class="empty-state-icon">üß†</div>
                            <div class="empty-state-text">Retrieved context will appear here when you ask a question.</div>
                        </div>
                    </div>
                    <div class="tab-pane" id="entitiesMatchTab">
                        <div class="empty-state">
                            <div class="empty-state-icon">üéØ</div>
                            <div class="empty-state-text">Matched entities will appear here.</div>
                        </div>
                    </div>
                    <div class="tab-pane" id="reasoningTab">
                        <div class="empty-state">
                            <div class="empty-state-icon">ü§î</div>
                            <div class="empty-state-text">Reasoning trace will appear here.</div>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </main>
</div>
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Debug script loading
    console.log('=== SCRIPT LOADING DEBUG ===');
    console.log('AuthManager available:', typeof window.AuthManager !== 'undefined');
    console.log('AuthManager type:', typeof window.AuthManager);
    console.log('AuthManager methods:', window.AuthManager ? Object.getOwnPropertyNames(Object.getPrototypeOf(window.AuthManager)) : 'N/A');
    console.log('authenticatedFetch method:', window.AuthManager ? typeof window.AuthManager.authenticatedFetch : 'N/A');
    console.log('API available:', typeof window.API !== 'undefined');
    console.log('appState available:', typeof appState !== 'undefined');
    console.log('AppConfig available:', typeof AppConfig !== 'undefined');
    console.log('============================');
    
    // Check authentication first
    if (typeof window.AuthManager === 'undefined') {
        console.error('AuthManager is not loaded');
        window.location.href = '/login';
        return;
    }

    if (!window.AuthManager.isAuthenticated()) {
        console.log('User not authenticated, redirecting to login');
        window.location.href = '/login';
        return;
    }
    
    console.log('User is authenticated, token:', window.AuthManager.getToken() ? 'present' : 'missing');

    // Initialize main app functionality
    initializeApp();
    
    async function initializeApp() {
        // Load user profile
        await loadUserProfile();
        
        // Load user's project
        await loadProject();
        
        // Load documents
        await loadDocuments();
        
        // Initialize event listeners
        initializeEventListeners();
        
        // Initialize file upload
        initializeFileUpload();
        
        // Initialize chat
        initializeChat();
        
        // Initialize tabs (with delay to ensure DOM is ready)
        setTimeout(() => {
            initializeTabs();
        }, 100);
        
        console.log('Main app initialized');
    }
    
    async function loadUserProfile() {
        try {
            const profile = await window.AuthManager.getProfile();
            if (profile) {
                document.getElementById('profileName').textContent = profile.email.split('@')[0];
                document.getElementById('profileAvatar').textContent = profile.email[0].toUpperCase();
                appState.setState({ user: profile });
            }
        } catch (error) {
            console.error('Failed to load profile:', error);
        }
    }
    
    async function loadProject() {
        try {
            console.log('Starting to load project...');
            console.log('AuthManager available:', typeof window.AuthManager !== 'undefined');
            console.log('API available:', typeof window.API !== 'undefined');
            console.log('User authenticated:', window.AuthManager?.isAuthenticated());
            console.log('Auth token exists:', !!window.AuthManager?.getToken());
            
            // Now use the API class which should work properly
            const project = await API.get('/projects/me');
            console.log('Project loaded successfully via API class:', project);
            appState.setState({ project });
            
            // Also update the UI to remove error messages
            const errorElements = document.querySelectorAll('.toast-error');
            errorElements.forEach(el => el.remove());
            
        } catch (error) {
            console.error('Failed to load project:', error);
            console.error('Error details:', error.message);
            console.error('Error stack:', error.stack);
            
            // Check if it's a 404 error (no project exists)
            if (error.message && error.message.includes('404')) {
                console.log('User has no project, redirecting to project creation');
                window.location.href = '/create-project';
                return;
            }
            
            // For other errors, show a console message but don't block the UI
            console.error('Failed to load project, but continuing. User can manually create one.');
            // Show in the UI that there's an issue
            if (typeof showToast === 'function') {
                showToast(`Project loading failed: ${error.message}`, 'error');
            }
        }
    }
    
    async function loadDocuments() {
        try {
            if (!appState.project) {
                console.log('No project available, skipping document loading');
                return;
            }
            
            console.log('Starting to load documents via API class...');
            const documentsResponse = await API.get('/documents');
            console.log('Documents loaded successfully via API class:', documentsResponse);
            
            // Extract documents array from the API response
            const documents = documentsResponse.documents || [];
            appState.setState({ documents });
            renderDocuments(documents);
        } catch (error) {
            console.error('Failed to load documents:', error);
        }
    }
    
    function renderDocuments(documents) {
        const container = document.getElementById('documentsList');
        
        console.log('renderDocuments called with:', documents.length, 'documents');
        console.log('container element:', container);
        
        if (!container) {
            console.error('Required DOM elements not found:', { container });
            return;
        }
        
        if (documents.length === 0) {
            container.innerHTML = `
                <div class="empty-state" id="documentsEmpty">
                    <div class="empty-state-icon">üìÑ</div>
                    <div class="empty-state-text">No documents uploaded yet.<br>Upload your first document to get started.</div>
                </div>
            `;
            return;
        }
        
        const html = documents.map(doc => `
            <div class="document-item" data-id="${doc.id}" onclick="selectDocument('${doc.id}')">
                <div class="document-icon">üìÑ</div>
                <div class="document-info">
                    <div class="document-title">${Utils.escapeHtml(doc.name || doc.title || 'Untitled')}</div>
                    <div class="document-meta">${doc.original_format || ''} ‚Ä¢ ${Utils.formatDate(doc.created_at)}</div>
                </div>
                <div class="document-actions">
                    <button class="action-btn" onclick="event.stopPropagation(); previewDocument('${doc.id}')" title="Preview">üëÅÔ∏è</button>
                    <button class="action-btn" onclick="event.stopPropagation(); deleteDocument('${doc.id}')" title="Delete">üóëÔ∏è</button>
                </div>
            </div>
        `).join('');
        
        container.innerHTML = html;
    }
    
    function initializeEventListeners() {
        // Profile dropdown
        document.getElementById('profileButton').addEventListener('click', function() {
            document.getElementById('profileDropdown').classList.toggle('active');
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.profile-dropdown')) {
                document.getElementById('profileDropdown').classList.remove('active');
            }
        });
        
        // Logout
        document.getElementById('logoutLink').addEventListener('click', function(e) {
            e.preventDefault();
            
            // Close dropdown first
            document.getElementById('profileDropdown').classList.remove('active');
            
            // Show confirmation and logout
            if (confirm('Are you sure you want to logout?')) {
                try {
                    window.AuthManager.logout();
                } catch (error) {
                    console.error('Logout error:', error);
                    // Force redirect if logout fails
                    window.location.href = '/login';
                }
            }
        });
        
        // Refresh buttons
        document.getElementById('refreshDocuments').addEventListener('click', loadDocuments);
        document.getElementById('refreshEntities').addEventListener('click', loadEntities);
        
        // Clear chat
        document.getElementById('clearChat').addEventListener('click', clearChat);
    }
    
    function initializeFileUpload() {
        const uploadButton = document.getElementById('uploadButton');
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');
        
        uploadButton.addEventListener('click', () => fileInput.click());
        
        fileInput.addEventListener('change', handleFileUpload);
        
        // Drag and drop
        dropZone.addEventListener('dragover', handleDragOver);
        dropZone.addEventListener('dragleave', handleDragLeave);
        dropZone.addEventListener('drop', handleFileDrop);
    }
    
    function handleDragOver(e) {
        e.preventDefault();
        document.getElementById('dropZone').classList.add('dragover');
    }
    
    function handleDragLeave(e) {
        e.preventDefault();
        document.getElementById('dropZone').classList.remove('dragover');
    }
    
    function handleFileDrop(e) {
        e.preventDefault();
        document.getElementById('dropZone').classList.remove('dragover');
        
        const files = Array.from(e.dataTransfer.files);
        handleFileUpload({ target: { files } });
    }
    
    async function handleFileUpload(e) {
        const files = Array.from(e.target.files);
        
        if (files.length === 0) return;
        
        // Validate files
        const validFiles = files.filter(file => {
            if (!Utils.validateFileType(file)) {
                showToast(`Invalid file type: ${file.name}`, 'error');
                return false;
            }
            if (!Utils.validateFileSize(file)) {
                showToast(`File too large: ${file.name}`, 'error');
                return false;
            }
            return true;
        });
        
        if (validFiles.length === 0) return;
        
        if (validFiles.length > AppConfig.maxFiles) {
            showToast(`Maximum ${AppConfig.maxFiles} files allowed`, 'error');
            return;
        }
        
        // Check if user has project
        console.log('=== FILE UPLOAD DEBUG ===');
        console.log('Current appState:', appState);
        console.log('Current appState.project:', appState.project);
        console.log('typeof appState.project:', typeof appState.project);
        console.log('appState.project === null:', appState.project === null);
        console.log('appState.project === undefined:', appState.project === undefined);
        console.log('==========================');
        
        if (!appState.project) {
            console.error('No project found in appState, project loading may have failed');
            console.error('Available appState keys:', Object.keys(appState));
            showToast('Please create a project first', 'error');
            return;
        }
        
        // Upload files using direct fetch
        for (const file of validFiles) {
            await uploadFileDirectly(file);
        }
        
        // Refresh documents list after upload
        console.log('Refreshing documents list after upload...');
        await loadDocuments();
    }
    
    async function uploadFileDirectly(file) {
        try {
            console.log('Starting direct file upload for:', file.name);
            
            const formData = new FormData();
            formData.append('file', file);
            
            const token = window.AuthManager.getToken();
            const response = await fetch('/api/documents/upload', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`
                },
                body: formData
            });
            
            console.log('Upload response status:', response.status);
            console.log('Upload response ok:', response.ok);
            
            if (response.ok) {
                const result = await response.json();
                console.log('File uploaded successfully:', result);
                showToast(`${file.name} uploaded successfully`, 'success');
                
                // Auto-trigger pipeline processing
                if (result.document_id) {
                    setTimeout(() => {
                        triggerPipelineProcessing(result.document_id, file.name);
                    }, 1000);
                }
            } else {
                const errorText = await response.text();
                console.error('Upload failed:', response.status, errorText);
                showToast(`Failed to upload ${file.name}: ${errorText}`, 'error');
            }
        } catch (error) {
            console.error('Upload error:', error);
            showToast(`Upload error: ${error.message}`, 'error');
        }
    }
    
    async function uploadFile(file) {
        try {
            const formData = new FormData();
            formData.append('file', file);
            
            const progressContainer = document.getElementById('uploadProgress');
            const progressFill = document.getElementById('progressFill');
            
            progressContainer.style.display = 'block';
            progressFill.style.width = '0%';
            
            // Simulate progress (you can implement real progress tracking)
            const progressInterval = setInterval(() => {
                const currentWidth = parseFloat(progressFill.style.width);
                if (currentWidth < 90) {
                    progressFill.style.width = (currentWidth + 10) + '%';
                }
            }, 200);
            
            const result = await API.upload('/documents/upload', formData);
            
            clearInterval(progressInterval);
            progressFill.style.width = '100%';
            
            setTimeout(() => {
                progressContainer.style.display = 'none';
            }, 1000);
            
            showToast(`${file.name} uploaded successfully`, 'success');
            
        } catch (error) {
            console.error('Upload failed:', error);
            showToast(`Upload failed: ${error.message}`, 'error');
            document.getElementById('uploadProgress').style.display = 'none';
        }
    }
    
    function initializeChat() {
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        
        messageInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 120) + 'px';
        });
        
        messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        sendButton.addEventListener('click', sendMessage);
    }
    
    async function sendMessage() {
        const input = document.getElementById('messageInput');
        const message = input.value.trim();
        
        if (!message) return;
        
        // Add user message to chat
        addChatMessage(message, 'user');
        
        // Clear input
        input.value = '';
        input.style.height = 'auto';
        
        // Show thinking
        setStatus('Processing', 'processing');
        
        try {
            // Send to backend (placeholder for now)
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Add bot response
            addChatMessage('I understand your question. However, the chat functionality is not fully implemented yet. Please check back later!', 'bot');
            
        } catch (error) {
            console.error('Chat error:', error);
            addChatMessage('Sorry, I encountered an error. Please try again.', 'bot');
        } finally {
            setStatus('Ready', 'idle');
        }
    }
    
    function addChatMessage(message, sender) {
        const chatWindow = document.getElementById('chatWindow');
        const emptyState = chatWindow.querySelector('.empty-state');
        
        if (emptyState) {
            emptyState.remove();
        }
        
        const messageElement = document.createElement('div');
        messageElement.className = `chat-message ${sender}`;
        messageElement.innerHTML = `
            <div class="message-content">${Utils.escapeHtml(message)}</div>
            <div class="message-time">${new Date().toLocaleTimeString()}</div>
        `;
        
        chatWindow.appendChild(messageElement);
        chatWindow.scrollTop = chatWindow.scrollHeight;
    }
    
    function clearChat() {
        const chatWindow = document.getElementById('chatWindow');
        chatWindow.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üí¨</div>
                <div class="empty-state-text">Start a conversation by asking a question about your documents.</div>
            </div>
        `;
    }
    
    function initializeTabs() {
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabGroup = this.closest('.tabs');
                if (!tabGroup) {
                    console.error('Tab group not found for tab:', this);
                    return;
                }
                
                const tabName = this.dataset.tab;
                if (!tabName) {
                    console.error('Tab name not found for tab:', this);
                    return;
                }
                
                // Find the content container - it's the next sibling of the tabs div
                const contentContainer = tabGroup.nextElementSibling;
                if (!contentContainer) {
                    console.error('Content container not found for tab group:', tabGroup);
                    return;
                }
                
                console.log('Tab clicked:', tabName, 'Content container:', contentContainer);
                
                // Update active tab
                tabGroup.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                // Update active content
                contentContainer.querySelectorAll('.tab-pane').forEach(pane => {
                    pane.classList.remove('active');
                });
                
                const targetPane = document.getElementById(tabName + 'Tab');
                if (targetPane) {
                    targetPane.classList.add('active');
                    console.log('Activated tab pane:', targetPane.id);
                } else {
                    console.error('Target pane not found:', tabName + 'Tab');
                }
            });
        });
    }
    
    function setStatus(text, type = 'idle') {
        document.getElementById('statusText').textContent = text;
        const dot = document.getElementById('statusDot');
        dot.className = `status-dot ${type}`;
        appState.setState({ status: text });
    }
    
    async function loadEntities() {
        if (!appState.selectedDocument) {
            showEntityEmptyState();
            return;
        }
        
        try {
            const project = appState.project;
            if (!project) {
                showToast('No project available', 'error');
                return;
            }
            
            // Load entities for the selected document
            const entitiesResponse = await API.get(`/entities/documents/${appState.selectedDocument.id}/entities?per_page=100`);
            const entities = entitiesResponse.entities || [];
            
            renderEntities(entities);
            
            // Also load relationships
            await loadRelationships();
            
            // Update graph tab with statistics
            updateGraphTab(entities);
            
        } catch (error) {
            console.error('Failed to load entities:', error);
            showToast('Failed to load entities', 'error');
            showEntityEmptyState();
        }
    }
    
    async function loadRelationships() {
        if (!appState.selectedDocument) {
            showRelationshipEmptyState();
            return;
        }
        
        try {
            const project = appState.project;
            if (!project) {
                return;
            }
            
            // Load relationships for the selected document
            const relationshipsResponse = await API.get(`/relationships/documents/${appState.selectedDocument.id}?per_page=100`);
            const relationships = relationshipsResponse.relationships || [];
            
            renderRelationships(relationships);
            
        } catch (error) {
            console.error('Failed to load relationships:', error);
            showToast('Failed to load relationships', 'error');
            showRelationshipEmptyState();
        }
    }
    
    function renderEntities(entities) {
        const entitiesTab = document.getElementById('entitiesTab');
        
        if (entities.length === 0) {
            showEntityEmptyState();
            return;
        }
        
        const html = entities.map(entity => `
            <div class="entity-item">
                <div class="entity-info">
                    <div class="entity-name">${Utils.escapeHtml(entity.entity_name)}</div>
                    <div class="entity-type">${entity.entity_type}</div>
                </div>
                <div class="entity-confidence">${(entity.confidence * 100).toFixed(0)}%</div>
            </div>
        `).join('');
        
        entitiesTab.innerHTML = html;
    }
    
    function renderRelationships(relationships) {
        const relationshipsTab = document.getElementById('relationshipsTab');
        
        if (relationships.length === 0) {
            showRelationshipEmptyState();
            return;
        }
        
        const html = relationships.map(rel => `
            <div class="relationship-item">
                <div class="relationship-info">
                    <div class="relationship-source">${Utils.escapeHtml(rel.source_entity?.entity_name || 'Unknown')}</div>
                    <div class="relationship-type">${rel.relationship_type}</div>
                    <div class="relationship-target">${Utils.escapeHtml(rel.target_entity?.entity_name || 'Unknown')}</div>
                </div>
                <div class="relationship-confidence">${(rel.confidence * 100).toFixed(0)}%</div>
            </div>
        `).join('');
        
        relationshipsTab.innerHTML = html;
    }
    
    function showEntityEmptyState() {
        const entitiesTab = document.getElementById('entitiesTab');
        entitiesTab.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üîç</div>
                <div class="empty-state-text">No entities found for this document.</div>
            </div>
        `;
    }
    
    function showRelationshipEmptyState() {
        const relationshipsTab = document.getElementById('relationshipsTab');
        relationshipsTab.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üîó</div>
                <div class="empty-state-text">No relationships found for this document.</div>
            </div>
        `;
    }
    
    function updateGraphTab(entities) {
        const graphTab = document.getElementById('graphTab');
        
        if (!entities || entities.length === 0) {
            graphTab.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">üï∏Ô∏è</div>
                    <div class="empty-state-text">No entities available for graph visualization.</div>
                </div>
            `;
            return;
        }
        
        // Count entities by type
        const entityTypeCounts = {};
        entities.forEach(entity => {
            const type = entity.entity_type;
            entityTypeCounts[type] = (entityTypeCounts[type] || 0) + 1;
        });
        
        const sortedTypes = Object.entries(entityTypeCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10); // Top 10 types
        
        const html = `
            <div class="graph-stats">
                <h4>Knowledge Graph Statistics</h4>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value">${entities.length}</div>
                        <div class="stat-label">Total Entities</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${Object.keys(entityTypeCounts).length}</div>
                        <div class="stat-label">Entity Types</div>
                    </div>
                </div>
                
                <h5>Top Entity Types</h5>
                <div class="entity-types-list">
                    ${sortedTypes.map(([type, count]) => `
                        <div class="entity-type-item">
                            <span class="entity-type-name">${type}</span>
                            <span class="entity-type-count">${count}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
        
        graphTab.innerHTML = html;
    }
    
    async function triggerPipelineProcessing(documentId, fileName) {
        try {
            console.log(`Starting pipeline processing for document: ${fileName}`);
            setStatus('Processing document...', 'processing');
            
            // Start pipeline processing
            const pipelineResponse = await API.post(`/pipeline/documents/${documentId}/process`);
            console.log('Pipeline started:', pipelineResponse);
            
            showToast(`Processing ${fileName}... (${pipelineResponse.execution_id.substring(0, 8)})`, 'info');
            
            // Monitor pipeline progress
            monitorPipelineProgress(pipelineResponse.execution_id, fileName);
            
        } catch (error) {
            console.error('Failed to start pipeline:', error);
            showToast(`Failed to process ${fileName}: ${error.message}`, 'error');
            setStatus('Ready', 'idle');
        }
    }
    
    async function monitorPipelineProgress(executionId, fileName) {
        const maxAttempts = 30;
        let attempts = 0;
        
        const checkProgress = async () => {
            try {
                const status = await API.get(`/pipeline/${executionId}/status`);
                console.log(`Pipeline progress for ${fileName}:`, status.status, status.current_stage);
                
                if (status.status === 'completed') {
                    setStatus('Ready', 'idle');
                    showToast(`‚úÖ ${fileName} processed successfully! Knowledge graph updated.`, 'success');
                    
                    // Refresh documents and knowledge graph if this document is selected
                    await loadDocuments();
                    if (appState.selectedDocument && appState.selectedDocument.id === status.document_id) {
                        await loadEntities();
                    }
                    return;
                }
                
                if (status.status === 'failed') {
                    setStatus('Ready', 'idle');
                    showToast(`‚ùå Failed to process ${fileName}`, 'error');
                    return;
                }
                
                // Still running, check again
                attempts++;
                if (attempts < maxAttempts) {
                    setTimeout(checkProgress, 2000);
                } else {
                    setStatus('Ready', 'idle');
                    showToast(`‚è±Ô∏è Processing ${fileName} is taking longer than expected`, 'warning');
                }
                
            } catch (error) {
                console.error('Error checking pipeline progress:', error);
                setStatus('Ready', 'idle');
            }
        };
        
        // Start monitoring
        setTimeout(checkProgress, 2000);
    }
    
    // Global functions for document actions
    window.selectDocument = function(docId) {
        // Update selected document in state
        const selectedDoc = appState.documents.find(doc => doc.id === docId);
        appState.setState({ selectedDocument: selectedDoc });
        
        // Update UI to show selected document
        const documentItems = document.querySelectorAll('.document-item');
        if (documentItems) {
            documentItems.forEach(item => {
                item.classList.remove('selected');
            });
        }
        
        const selectedItem = document.querySelector(`[data-id="${docId}"]`);
        if (selectedItem) {
            selectedItem.classList.add('selected');
        }
        
        // Update knowledge graph section title
        const sectionTitle = document.querySelector('.entity-viewer .section-title');
        if (sectionTitle && selectedDoc) {
            sectionTitle.textContent = `Knowledge Graph - ${selectedDoc.name}`;
        }
        
        // Load knowledge graph data for selected document
        loadEntities();
        
        console.log('Selected document:', selectedDoc);
    };
    
    window.previewDocument = function(docId) {
        showToast('Document preview not implemented yet', 'info');
    };
    
    window.deleteDocument = async function(docId) {
        if (!confirm('Are you sure you want to delete this document?')) return;
        
        try {
            await API.delete(`/documents/${docId}`);
            showToast('Document deleted successfully', 'success');
            
            // Clear selection if deleted document was selected
            if (appState.selectedDocument && appState.selectedDocument.id === docId) {
                appState.setState({ selectedDocument: null });
                document.querySelector('.entity-viewer .section-title').textContent = 'Knowledge Graph';
                showEntityEmptyState();
                showRelationshipEmptyState();
            }
            
            await loadDocuments();
        } catch (error) {
            console.error('Delete failed:', error);
            showToast('Failed to delete document', 'error');
        }
    };
});
</script>
{% endblock %}
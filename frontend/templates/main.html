{% extends "base.html" %}

{% block title %}LightRAG - Knowledge Assistant{% endblock %}

{% block body_class %}main-app{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="/static/css/main.css">
{% endblock %}

{% block content %}
<div class="app-container">
    <!-- Header -->
    <header class="app-header">
        <div class="app-logo">LightRAG</div>
        
        <div class="status-indicator">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Ready</span>
        </div>
        
        <div class="user-profile">
            <!-- Emergency logout button for debugging -->
            <button onclick="window.AuthManager.logout()" style="margin-right: 10px; padding: 5px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Logout</button>
            
            <div class="profile-dropdown">
                <button class="profile-button" id="profileButton">
                    <div class="profile-avatar" id="profileAvatar">U</div>
                    <span id="profileName">User</span>
                    <span>‚ñº</span>
                </button>
                <div class="dropdown-content" id="profileDropdown">
                    <a href="#" class="dropdown-item" id="profileLink">Profile</a>
                    <a href="#" class="dropdown-item" id="logoutLink">Logout</a>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="app-main">
        <!-- Left Column - Document Management -->
        <div class="left-column">
            <!-- Upload Section -->
            <section class="upload-section">
                <button class="upload-button" id="uploadButton">
                    Upload Document
                </button>
                
                <div class="drop-zone" id="dropZone">
                    <div class="drop-zone-content">
                        <div class="drop-zone-icon">üìÅ</div>
                        <p>Drag & drop files here</p>
                        <p class="text-xs text-muted">PDF, DOCX, TXT, MD ‚Ä¢ Max 5MB ‚Ä¢ Up to 5 files</p>
                    </div>
                </div>
                
                <div class="upload-progress" id="uploadProgress" style="display: none;">
                    <div class="text-sm mb-2">Uploading...</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                </div>
                
                <input type="file" id="fileInput" multiple accept=".pdf,.docx,.txt,.md" style="display: none;">
            </section>

            <!-- Documents List -->
            <section class="documents-section">
                <div class="section-header">
                    <h3 class="section-title">Documents</h3>
                    <button class="btn btn-sm btn-ghost" id="refreshDocuments">Refresh</button>
                </div>
                
                <div class="documents-list" id="documentsList">
                </div>
            </section>

            <!-- Entity Viewer -->
            <section class="entity-viewer">
                <div class="section-header">
                    <h3 class="section-title">Knowledge Graph</h3>
                    <button class="btn btn-sm btn-ghost" id="refreshEntities">Refresh</button>
                </div>
                
                <div class="tabs">
                    <button class="tab active" data-tab="entities">Entities</button>
                    <button class="tab" data-tab="graph">Graph</button>
                    <button class="tab" data-tab="relationships">Relations</button>
                </div>
                
                <div class="tab-content" id="tabContent">
                    <div class="tab-pane active" id="entitiesTab">
                        <div class="empty-state">
                            <div class="empty-state-icon">üîç</div>
                            <div class="empty-state-text">No entities extracted yet.</div>
                        </div>
                    </div>
                    <div class="tab-pane" id="graphTab">
                        <div class="empty-state">
                            <div class="empty-state-icon">üï∏Ô∏è</div>
                            <div class="empty-state-text">Knowledge graph will appear here.</div>
                        </div>
                    </div>
                    <div class="tab-pane" id="relationshipsTab">
                        <div class="empty-state">
                            <div class="empty-state-icon">üîó</div>
                            <div class="empty-state-text">No relationships found yet.</div>
                        </div>
                    </div>
                </div>
            </section>
        </div>

        <!-- Right Column - Chat Interface -->
        <div class="right-column">
            <!-- Chat Section -->
            <section class="chat-section">
                <div class="section-header">
                    <h3 class="section-title">Chat</h3>
                    <button class="btn btn-sm btn-ghost" id="clearChat">Clear</button>
                </div>
                
                <div class="chat-window" id="chatWindow">
                    <div class="empty-state">
                        <div class="empty-state-icon">üí¨</div>
                        <div class="empty-state-text">Start a conversation by asking a question about your documents.</div>
                    </div>
                </div>
                
                <div class="chat-input-area">
                    <textarea 
                        class="chat-input" 
                        id="messageInput" 
                        placeholder="Ask a question about your documents..."
                        rows="1"
                    ></textarea>
                    
                    <div class="chat-controls">
                        <label class="rag-toggle">
                            <input type="checkbox" id="useRag" checked>
                            <span>Use RAG</span>
                        </label>
                        <button class="send-button" id="sendButton">
                            <span>‚ñ∂</span>
                        </button>
                    </div>
                </div>
            </section>

            <!-- Thinking Panel -->
            <section class="thinking-panel">
                <div class="section-header">
                    <h3 class="section-title">Thinking Process</h3>
                    <div class="tabs">
                        <button class="tab active" data-tab="context">Context</button>
                        <button class="tab" data-tab="entities-match">Entities</button>
                        <button class="tab" data-tab="reasoning">Reasoning</button>
                    </div>
                </div>
                
                <div class="thinking-content" id="thinkingContent">
                    <div class="tab-pane active" id="contextTab">
                        <div class="empty-state">
                            <div class="empty-state-icon">üß†</div>
                            <div class="empty-state-text">Retrieved context will appear here when you ask a question.</div>
                        </div>
                    </div>
                    <div class="tab-pane" id="entitiesMatchTab">
                        <div class="empty-state">
                            <div class="empty-state-icon">üéØ</div>
                            <div class="empty-state-text">Matched entities will appear here.</div>
                        </div>
                    </div>
                    <div class="tab-pane" id="reasoningTab">
                        <div class="empty-state">
                            <div class="empty-state-icon">ü§î</div>
                            <div class="empty-state-text">Reasoning trace will appear here.</div>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </main>
</div>
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Debug script loading
    console.log('=== SCRIPT LOADING DEBUG ===');
    console.log('AuthManager available:', typeof window.AuthManager !== 'undefined');
    console.log('AuthManager type:', typeof window.AuthManager);
    console.log('AuthManager methods:', window.AuthManager ? Object.getOwnPropertyNames(Object.getPrototypeOf(window.AuthManager)) : 'N/A');
    console.log('authenticatedFetch method:', window.AuthManager ? typeof window.AuthManager.authenticatedFetch : 'N/A');
    console.log('API available:', typeof window.API !== 'undefined');
    console.log('appState available:', typeof appState !== 'undefined');
    console.log('AppConfig available:', typeof AppConfig !== 'undefined');
    console.log('============================');
    
    // Check authentication first
    if (typeof window.AuthManager === 'undefined') {
        console.error('AuthManager is not loaded');
        window.location.href = '/login';
        return;
    }

    if (!window.AuthManager.isAuthenticated()) {
        console.log('User not authenticated, redirecting to login');
        window.location.href = '/login';
        return;
    }
    
    console.log('User is authenticated, token:', window.AuthManager.getToken() ? 'present' : 'missing');

    // Initialize main app functionality
    initializeApp();
    
    async function initializeApp() {
        // Load user profile
        await loadUserProfile();
        
        // Load user's project
        await loadProject();
        
        // Load documents
        await loadDocuments();
        
        // Initialize event listeners
        initializeEventListeners();
        
        // Initialize file upload
        initializeFileUpload();
        
        // Initialize chat
        initializeChat();
        
        // Load chat history
        loadChatHistory();
        
        // Initialize tabs (with delay to ensure DOM is ready)
        setTimeout(() => {
            initializeTabs();
        }, 100);
        
        console.log('Main app initialized');
    }
    
    async function loadUserProfile() {
        try {
            const profile = await window.AuthManager.getProfile();
            if (profile) {
                document.getElementById('profileName').textContent = profile.email.split('@')[0];
                document.getElementById('profileAvatar').textContent = profile.email[0].toUpperCase();
                appState.setState({ user: profile });
            }
        } catch (error) {
            console.error('Failed to load profile:', error);
        }
    }
    
    async function loadProject() {
        try {
            console.log('Starting to load project...');
            console.log('AuthManager available:', typeof window.AuthManager !== 'undefined');
            console.log('API available:', typeof window.API !== 'undefined');
            console.log('User authenticated:', window.AuthManager?.isAuthenticated());
            console.log('Auth token exists:', !!window.AuthManager?.getToken());
            
            // Now use the API class which should work properly
            const project = await API.get('/projects/me');
            console.log('Project loaded successfully via API class:', project);
            appState.setState({ project });
            
            // Also update the UI to remove error messages
            const errorElements = document.querySelectorAll('.toast-error');
            errorElements.forEach(el => el.remove());
            
        } catch (error) {
            console.error('Failed to load project:', error);
            console.error('Error details:', error.message);
            console.error('Error stack:', error.stack);
            
            // Check if it's a 404 error (no project exists)
            if (error.message && error.message.includes('404')) {
                console.log('User has no project, redirecting to project creation');
                window.location.href = '/create-project';
                return;
            }
            
            // For other errors, show a console message but don't block the UI
            console.error('Failed to load project, but continuing. User can manually create one.');
            // Show in the UI that there's an issue
            if (typeof showToast === 'function') {
                showToast(`Project loading failed: ${error.message}`, 'error');
            }
        }
    }
    
    async function loadDocuments() {
        try {
            if (!appState.project) {
                console.log('No project available, skipping document loading');
                return;
            }
            
            console.log('Starting to load documents via API class...');
            const documentsResponse = await API.get('/documents');
            console.log('Documents loaded successfully via API class:', documentsResponse);
            
            // Extract documents array from the API response
            const documents = documentsResponse.documents || [];
            appState.setState({ documents });
            renderDocuments(documents);
        } catch (error) {
            console.error('Failed to load documents:', error);
        }
    }
    
    function renderDocuments(documents) {
        const container = document.getElementById('documentsList');
        
        console.log('renderDocuments called with:', documents.length, 'documents');
        console.log('container element:', container);
        
        if (!container) {
            console.error('Required DOM elements not found:', { container });
            return;
        }
        
        if (documents.length === 0) {
            container.innerHTML = `
                <div class="empty-state" id="documentsEmpty">
                    <div class="empty-state-icon">üìÑ</div>
                    <div class="empty-state-text">No documents uploaded yet.<br>Upload your first document to get started.</div>
                </div>
            `;
            return;
        }
        
        const html = documents.map(doc => `
            <div class="document-item" data-id="${doc.id}" onclick="selectDocument('${doc.id}')">
                <div class="document-icon">üìÑ</div>
                <div class="document-info">
                    <div class="document-title">${Utils.escapeHtml(doc.name || doc.title || 'Untitled')}</div>
                    <div class="document-meta">${doc.original_format || ''} ‚Ä¢ ${Utils.formatDate(doc.created_at)}</div>
                </div>
                <div class="document-actions">
                    <button class="action-btn" onclick="event.stopPropagation(); previewDocument('${doc.id}')" title="Preview">üëÅÔ∏è</button>
                    <button class="action-btn" onclick="event.stopPropagation(); deleteDocument('${doc.id}')" title="Delete">üóëÔ∏è</button>
                </div>
            </div>
        `).join('');
        
        container.innerHTML = html;
    }
    
    function initializeEventListeners() {
        // Profile dropdown
        document.getElementById('profileButton').addEventListener('click', function() {
            document.getElementById('profileDropdown').classList.toggle('active');
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.profile-dropdown')) {
                document.getElementById('profileDropdown').classList.remove('active');
            }
        });
        
        // Logout
        document.getElementById('logoutLink').addEventListener('click', function(e) {
            e.preventDefault();
            
            // Close dropdown first
            document.getElementById('profileDropdown').classList.remove('active');
            
            // Show confirmation and logout
            if (confirm('Are you sure you want to logout?')) {
                try {
                    window.AuthManager.logout();
                } catch (error) {
                    console.error('Logout error:', error);
                    // Force redirect if logout fails
                    window.location.href = '/login';
                }
            }
        });
        
        // Refresh buttons
        document.getElementById('refreshDocuments').addEventListener('click', loadDocuments);
        document.getElementById('refreshEntities').addEventListener('click', loadEntities);
        
        // Clear chat
        document.getElementById('clearChat').addEventListener('click', clearChat);
    }
    
    function initializeFileUpload() {
        const uploadButton = document.getElementById('uploadButton');
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');
        
        uploadButton.addEventListener('click', () => fileInput.click());
        
        fileInput.addEventListener('change', handleFileUpload);
        
        // Drag and drop
        dropZone.addEventListener('dragover', handleDragOver);
        dropZone.addEventListener('dragleave', handleDragLeave);
        dropZone.addEventListener('drop', handleFileDrop);
    }
    
    function handleDragOver(e) {
        e.preventDefault();
        document.getElementById('dropZone').classList.add('dragover');
    }
    
    function handleDragLeave(e) {
        e.preventDefault();
        document.getElementById('dropZone').classList.remove('dragover');
    }
    
    function handleFileDrop(e) {
        e.preventDefault();
        document.getElementById('dropZone').classList.remove('dragover');
        
        const files = Array.from(e.dataTransfer.files);
        handleFileUpload({ target: { files } });
    }
    
    async function handleFileUpload(e) {
        const files = Array.from(e.target.files);
        
        if (files.length === 0) return;
        
        // Validate files
        const validFiles = files.filter(file => {
            if (!Utils.validateFileType(file)) {
                showToast(`Invalid file type: ${file.name}`, 'error');
                return false;
            }
            if (!Utils.validateFileSize(file)) {
                showToast(`File too large: ${file.name}`, 'error');
                return false;
            }
            return true;
        });
        
        if (validFiles.length === 0) return;
        
        if (validFiles.length > AppConfig.maxFiles) {
            showToast(`Maximum ${AppConfig.maxFiles} files allowed`, 'error');
            return;
        }
        
        // Check if user has project
        console.log('=== FILE UPLOAD DEBUG ===');
        console.log('Current appState:', appState);
        console.log('Current appState.project:', appState.project);
        console.log('typeof appState.project:', typeof appState.project);
        console.log('appState.project === null:', appState.project === null);
        console.log('appState.project === undefined:', appState.project === undefined);
        console.log('==========================');
        
        if (!appState.project) {
            console.error('No project found in appState, project loading may have failed');
            console.error('Available appState keys:', Object.keys(appState));
            showToast('Please create a project first', 'error');
            return;
        }
        
        // Upload files using direct fetch
        for (const file of validFiles) {
            await uploadFileDirectly(file);
        }
        
        // Refresh documents list after upload
        console.log('Refreshing documents list after upload...');
        await loadDocuments();
    }
    
    async function uploadFileDirectly(file) {
        try {
            console.log('Starting direct file upload for:', file.name);
            
            const formData = new FormData();
            formData.append('file', file);
            
            const token = window.AuthManager.getToken();
            const response = await fetch('/api/documents/upload', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`
                },
                body: formData
            });
            
            console.log('Upload response status:', response.status);
            console.log('Upload response ok:', response.ok);
            
            if (response.ok) {
                const result = await response.json();
                console.log('File uploaded successfully:', result);
                showToast(`${file.name} uploaded successfully`, 'success');
                
                // Auto-trigger pipeline processing
                if (result.document_id) {
                    setTimeout(() => {
                        triggerPipelineProcessing(result.document_id, file.name);
                    }, 1000);
                }
            } else {
                const errorText = await response.text();
                console.error('Upload failed:', response.status, errorText);
                showToast(`Failed to upload ${file.name}: ${errorText}`, 'error');
            }
        } catch (error) {
            console.error('Upload error:', error);
            showToast(`Upload error: ${error.message}`, 'error');
        }
    }
    
    async function uploadFile(file) {
        try {
            const formData = new FormData();
            formData.append('file', file);
            
            const progressContainer = document.getElementById('uploadProgress');
            const progressFill = document.getElementById('progressFill');
            
            progressContainer.style.display = 'block';
            progressFill.style.width = '0%';
            
            // Simulate progress (you can implement real progress tracking)
            const progressInterval = setInterval(() => {
                const currentWidth = parseFloat(progressFill.style.width);
                if (currentWidth < 90) {
                    progressFill.style.width = (currentWidth + 10) + '%';
                }
            }, 200);
            
            const result = await API.upload('/documents/upload', formData);
            
            clearInterval(progressInterval);
            progressFill.style.width = '100%';
            
            setTimeout(() => {
                progressContainer.style.display = 'none';
            }, 1000);
            
            showToast(`${file.name} uploaded successfully`, 'success');
            
        } catch (error) {
            console.error('Upload failed:', error);
            showToast(`Upload failed: ${error.message}`, 'error');
            document.getElementById('uploadProgress').style.display = 'none';
        }
    }
    
    function initializeChat() {
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        
        messageInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 120) + 'px';
        });
        
        messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        sendButton.addEventListener('click', sendMessage);
    }
    
    async function sendMessage() {
        const input = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const message = input.value.trim();
        
        if (!message) return;
        
        // Check if user has documents
        if (!appState.documents || appState.documents.length === 0) {
            addChatMessage('Please upload some documents first before asking questions.', 'bot');
            showToast('No documents found. Upload documents to get started.', 'warning');
            return;
        }
        
        // Add user message to chat
        addChatMessage(message, 'user');
        
        // Clear input and disable send button
        input.value = '';
        input.style.height = 'auto';
        sendButton.disabled = true;
        sendButton.innerHTML = '<span>...</span>';
        
        // Show thinking indicator
        setStatus('Processing query...', 'processing');
        
        // Add a "thinking" message
        const thinkingMessage = addChatMessage('Processing your question...', 'bot', { isThinking: true });
        
        // Show processing indicator in thinking panel
        updateThinkingPanelProcessing();
        
        try {
            // Get user ID from authentication
            const profile = await window.AuthManager.getProfile();
            const userId = profile?.uid || 'anonymous';
            
            // Prepare query request
            const queryRequest = {
                query: message,
                user_id: userId,
                project_id: appState.project?.id || null,
                max_results: 10,
                include_sources: true
            };
            
            console.log('Sending query request:', queryRequest);
            
            // Send to backend queries/process endpoint
            const response = await API.post('/queries/process', queryRequest);
            
            console.log('Query response:', response);
            
            // Remove thinking message
            if (thinkingMessage) {
                thinkingMessage.remove();
            }
            
            // Validate response
            if (!response.answer) {
                throw new Error('No answer received from the server');
            }
            
            // Add bot response with streaming effect
            await streamBotResponse(response.answer, {
                sources: response.sources,
                confidence: response.confidence,
                processingTime: response.processing_time,
                metadata: response.metadata
            });
            
            // Update thinking panel with metadata
            console.log('About to update thinking panel with response:', response);
            updateThinkingPanel(response.metadata);
            
            // Save to local conversation history
            saveChatHistoryLocally(message, response);
            
        } catch (error) {
            console.error('Chat error:', error);
            
            // Remove thinking message if it exists
            if (thinkingMessage) {
                thinkingMessage.remove();
            }
            
            let errorMessage = 'Sorry, I encountered an error processing your query. Please try again.';
            let toastMessage = 'Query failed';
            
            // Handle specific error types
            if (error.message.includes('404')) {
                errorMessage = 'The query service is not available. Please check if your documents are properly processed.';
                toastMessage = 'Query service not available';
            } else if (error.message.includes('401')) {
                errorMessage = 'Authentication error. Please refresh the page and try again.';
                toastMessage = 'Authentication error';
            } else if (error.message.includes('timeout')) {
                errorMessage = 'Query took too long to process. Please try a simpler question.';
                toastMessage = 'Query timeout';
            } else if (error.message.includes('No answer')) {
                errorMessage = 'I was unable to generate an answer. Please try rephrasing your question.';
                toastMessage = 'No answer generated';
            }
            
            addChatMessage(errorMessage, 'bot');
            showToast(`${toastMessage}: ${error.message}`, 'error');
            
            // Reset thinking panel on error
            resetThinkingPanel();
        } finally {
            // Re-enable send button
            sendButton.disabled = false;
            sendButton.innerHTML = '<span>‚ñ∂</span>';
            setStatus('Ready', 'idle');
        }
    }
    
    function addChatMessage(message, sender, metadata = {}) {
        const chatWindow = document.getElementById('chatWindow');
        const emptyState = chatWindow.querySelector('.empty-state');
        
        if (emptyState) {
            emptyState.remove();
        }
        
        const messageElement = document.createElement('div');
        messageElement.className = `chat-message ${sender}`;
        
        // Add thinking class for loading messages
        if (metadata.isThinking) {
            messageElement.classList.add('thinking');
        }
        
        let messageHtml = `
            <div class="message-content">${sender === 'bot' && !metadata.isThinking ? formatBotMessage(message) : Utils.escapeHtml(message)}</div>
            <div class="message-time">${new Date().toLocaleTimeString()}</div>
        `;
        
        // Add sources and metadata for bot responses
        if (sender === 'bot' && metadata && !metadata.isThinking) {
            if (metadata.sources && metadata.sources.length > 0) {
                messageHtml += `
                    <div class="message-sources">
                        <div class="sources-header">Sources:</div>
                        <div class="sources-list">
                            ${metadata.sources.map(source => {
                                // Format source name - if it's a document name, show it nicely
                                let displayName = source;
                                if (source === 'unknown' || !source) {
                                    displayName = 'Document';
                                } else if (source.includes('.')) {
                                    // If it's a filename, remove extension for display
                                    displayName = source.split('.').slice(0, -1).join('.');
                                }
                                return `<div class="source-item">${Utils.escapeHtml(displayName)}</div>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }
            
            if (metadata.confidence !== undefined) {
                const confidencePercent = Math.round(metadata.confidence * 100);
                messageHtml += `
                    <div class="message-metadata">
                        <span class="confidence-badge confidence-${confidencePercent >= 80 ? 'high' : confidencePercent >= 60 ? 'medium' : 'low'}">
                            ${confidencePercent}% confidence
                        </span>
                        ${metadata.processingTime ? `
                            <span class="processing-time">
                                ${metadata.processingTime.toFixed(2)}s
                            </span>
                        ` : ''}
                    </div>
                `;
            }
        }
        
        messageElement.innerHTML = messageHtml;
        
        chatWindow.appendChild(messageElement);
        chatWindow.scrollTop = chatWindow.scrollHeight;
        
        return messageElement;
    }
    
    function formatBotMessage(message) {
        // Convert plain text to HTML with proper formatting
        let formatted = Utils.escapeHtml(message);
        
        // Convert bullet points (- item) to HTML list items
        formatted = formatted.replace(/^- (.+)$/gm, '<li>$1</li>');
        
        // Wrap consecutive list items in <ul> tags
        formatted = formatted.replace(/(<li>.*<\/li>)/gs, (match) => {
            return `<ul>${match}</ul>`;
        });
        
        // Convert numbered lists (1. item) to HTML ordered lists
        formatted = formatted.replace(/^(\d+)\. (.+)$/gm, '<li>$2</li>');
        
        // Convert line breaks to <br> tags
        formatted = formatted.replace(/\n/g, '<br>');
        
        // Convert double line breaks to paragraph breaks
        formatted = formatted.replace(/<br><br>/g, '</p><p>');
        
        // Wrap in paragraph tags if not already wrapped
        if (!formatted.includes('<p>') && !formatted.includes('<ul>') && !formatted.includes('<ol>')) {
            formatted = `<p>${formatted}</p>`;
        } else if (formatted.includes('<br>')) {
            formatted = `<p>${formatted}</p>`;
        }
        
        // Bold text formatting (**text** -> <strong>text</strong>)
        formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        
        // Italic text formatting (*text* -> <em>text</em>)
        formatted = formatted.replace(/\*(.*?)\*/g, '<em>$1</em>');
        
        return formatted;
    }
    
    async function streamBotResponse(fullMessage, metadata) {
        const chatWindow = document.getElementById('chatWindow');
        const emptyState = chatWindow.querySelector('.empty-state');
        
        if (emptyState) {
            emptyState.remove();
        }
        
        // Create message element
        const messageElement = document.createElement('div');
        messageElement.className = 'chat-message bot streaming';
        
        // Create content div for streaming
        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        
        const timeDiv = document.createElement('div');
        timeDiv.className = 'message-time';
        timeDiv.textContent = new Date().toLocaleTimeString();
        
        messageElement.appendChild(contentDiv);
        messageElement.appendChild(timeDiv);
        
        chatWindow.appendChild(messageElement);
        chatWindow.scrollTop = chatWindow.scrollHeight;
        
        // Stream the text character by character
        const words = fullMessage.split(' ');
        let currentText = '';
        
        for (let i = 0; i < words.length; i++) {
            currentText += (i > 0 ? ' ' : '') + words[i];
            
            // Format and update content
            contentDiv.innerHTML = formatBotMessage(currentText);
            
            // Scroll to bottom
            chatWindow.scrollTop = chatWindow.scrollHeight;
            
            // Wait a bit before next word (adjust speed here)
            await new Promise(resolve => setTimeout(resolve, 50 + Math.random() * 50));
        }
        
        // Remove streaming class
        messageElement.classList.remove('streaming');
        
        // Add sources and metadata after streaming is complete
        if (metadata.sources && metadata.sources.length > 0) {
            const sourcesDiv = document.createElement('div');
            sourcesDiv.className = 'message-sources';
            sourcesDiv.innerHTML = `
                <div class="sources-header">Sources:</div>
                <div class="sources-list">
                    ${metadata.sources.map(source => {
                        let displayName = source;
                        if (source === 'unknown' || !source) {
                            displayName = 'Document';
                        } else if (source.includes('.')) {
                            displayName = source.split('.').slice(0, -1).join('.');
                        }
                        return `<div class="source-item">${Utils.escapeHtml(displayName)}</div>`;
                    }).join('')}
                </div>
            `;
            messageElement.appendChild(sourcesDiv);
        }
        
        if (metadata.confidence !== undefined) {
            const confidencePercent = Math.round(metadata.confidence * 100);
            const metadataDiv = document.createElement('div');
            metadataDiv.className = 'message-metadata';
            metadataDiv.innerHTML = `
                <span class="confidence-badge confidence-${confidencePercent >= 80 ? 'high' : confidencePercent >= 60 ? 'medium' : 'low'}">
                    ${confidencePercent}% confidence
                </span>
                ${metadata.processingTime ? `
                    <span class="processing-time">
                        ${metadata.processingTime.toFixed(2)}s
                    </span>
                ` : ''}
            `;
            messageElement.appendChild(metadataDiv);
        }
        
        // Final scroll to bottom
        chatWindow.scrollTop = chatWindow.scrollHeight;
        
        return messageElement;
    }
    
    function clearChat() {
        const chatWindow = document.getElementById('chatWindow');
        chatWindow.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üí¨</div>
                <div class="empty-state-text">Start a conversation by asking a question about your documents.</div>
            </div>
        `;
        
        // Also clear thinking panel
        resetThinkingPanel();
        
        // Clear local history for this session
        clearLocalChatHistory();
    }
    
    function saveChatHistoryLocally(userMessage, response) {
        try {
            const history = getLocalChatHistory();
            const newEntry = {
                id: Date.now().toString(),
                timestamp: new Date().toISOString(),
                userMessage: userMessage,
                botResponse: response.answer,
                sources: response.sources,
                confidence: response.confidence,
                processingTime: response.processing_time,
                metadata: response.metadata
            };
            
            history.push(newEntry);
            
            // Keep only last 50 conversations
            if (history.length > 50) {
                history.splice(0, history.length - 50);
            }
            
            localStorage.setItem('lightrag_chat_history', JSON.stringify(history));
            console.log('Chat history saved locally');
        } catch (error) {
            console.error('Failed to save chat history:', error);
        }
    }
    
    function getLocalChatHistory() {
        try {
            const history = localStorage.getItem('lightrag_chat_history');
            return history ? JSON.parse(history) : [];
        } catch (error) {
            console.error('Failed to get chat history:', error);
            return [];
        }
    }
    
    function clearLocalChatHistory() {
        try {
            localStorage.removeItem('lightrag_chat_history');
            console.log('Chat history cleared');
        } catch (error) {
            console.error('Failed to clear chat history:', error);
        }
    }
    
    function loadChatHistory() {
        try {
            const history = getLocalChatHistory();
            const chatWindow = document.getElementById('chatWindow');
            
            if (history.length === 0) return;
            
            // Clear empty state
            const emptyState = chatWindow.querySelector('.empty-state');
            if (emptyState) {
                emptyState.remove();
            }
            
            // Add historical messages
            history.forEach(entry => {
                addChatMessage(entry.userMessage, 'user');
                addChatMessage(entry.botResponse, 'bot', {
                    sources: entry.sources,
                    confidence: entry.confidence,
                    processingTime: entry.processingTime,
                    metadata: entry.metadata
                });
            });
            
            console.log(`Loaded ${history.length} chat history entries`);
        } catch (error) {
            console.error('Failed to load chat history:', error);
        }
    }
    
    function updateThinkingPanelProcessing() {
        // Show processing state in thinking panel
        const contextTab = document.getElementById('contextTab');
        const entitiesMatchTab = document.getElementById('entitiesMatchTab');
        const reasoningTab = document.getElementById('reasoningTab');
        
        if (contextTab) {
            contextTab.innerHTML = `
                <div class="processing-indicator">
                    <div class="spinner-small"></div>
                    <div class="processing-text">Searching and ranking documents...</div>
                </div>
            `;
        }
        
        if (entitiesMatchTab) {
            entitiesMatchTab.innerHTML = `
                <div class="processing-indicator">
                    <div class="spinner-small"></div>
                    <div class="processing-text">Extracting entities from query...</div>
                </div>
            `;
        }
        
        if (reasoningTab) {
            reasoningTab.innerHTML = `
                <div class="processing-indicator">
                    <div class="spinner-small"></div>
                    <div class="processing-text">Decomposing and expanding query...</div>
                </div>
            `;
        }
    }
    
    function updateThinkingPanel(metadata) {
        if (!metadata) return;
        
        console.log('Updating thinking panel with metadata:', metadata);
        
        // Test if the tab exists
        const contextTab = document.getElementById('contextTab');
        console.log('contextTab element:', contextTab);
        
        // Update context tab with actual metadata structure
        if (contextTab) {
            let contextHtml = '';
            
            // Show search optimization info
            if (metadata.search_optimization) {
                const searchOpt = metadata.search_optimization;
                contextHtml += `
                    <div class="context-summary">
                        <div class="context-stats">
                            <span>Search Results: ${searchOpt.original_results?.total_count || 0}</span>
                            <span>Reranked: ${searchOpt.reranked_count || 0}</span>
                        </div>
                    </div>
                `;
                
                // Show breakdown of results
                if (searchOpt.original_results) {
                    contextHtml += `
                        <div class="search-breakdown">
                            <div class="search-type">Keyword: ${searchOpt.original_results.keyword_count}</div>
                            <div class="search-type">Semantic: ${searchOpt.original_results.semantic_count}</div>
                            <div class="search-type">Graph: ${searchOpt.original_results.graph_count}</div>
                        </div>
                    `;
                }
            }
            
            // Show context information
            if (metadata.context_items !== undefined) {
                contextHtml += `
                    <div class="context-info">
                        <div class="context-stat">Context Items: ${metadata.context_items}</div>
                        <div class="context-stat">Context Tokens: ${metadata.context_tokens}</div>
                        <div class="context-stat">Sources: ${metadata.source_count}</div>
                        <div class="context-stat">Avg Relevance: ${Math.round((metadata.avg_relevance || 0) * 100)}%</div>
                    </div>
                `;
            }
            
            // Show adaptive context info
            if (metadata.adaptive_context) {
                const adaptive = metadata.adaptive_context;
                contextHtml += `
                    <div class="adaptive-context">
                        <div class="adaptive-title">Adaptive Context</div>
                        <div class="adaptive-stat">Complexity: ${adaptive.complexity_level}</div>
                        <div class="adaptive-stat">Recommended Tokens: ${adaptive.recommended_tokens}</div>
                        <div class="adaptive-stat">Actual Tokens: ${adaptive.actual_tokens}</div>
                        ${adaptive.reasoning ? `<div class="adaptive-reasoning">${Utils.escapeHtml(adaptive.reasoning)}</div>` : ''}
                    </div>
                `;
            }
            
            contextTab.innerHTML = contextHtml || `
                <div class="empty-state">
                    <div class="empty-state-icon">üß†</div>
                    <div class="empty-state-text">No context information available.</div>
                </div>
            `;
        }
        
        // Update entities tab with decomposition info
        const entitiesMatchTab = document.getElementById('entitiesMatchTab');
        if (entitiesMatchTab) {
            let entitiesHtml = '';
            
            // Show decomposition entities
            if (metadata.decomposition?.entities && metadata.decomposition.entities.length > 0) {
                entitiesHtml += `
                    <div class="entities-summary">
                        Found ${metadata.decomposition.entities.length} entities in query
                    </div>
                    <div class="matched-entities">
                        ${metadata.decomposition.entities.map(entity => `
                            <div class="matched-entity">
                                <div class="entity-name">${Utils.escapeHtml(entity)}</div>
                                <div class="entity-type">Query Entity</div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            // Show conversation context entities
            if (metadata.conversation_context?.extracted_entities && metadata.conversation_context.extracted_entities.length > 0) {
                entitiesHtml += `
                    <div class="entities-summary">
                        Conversation entities: ${metadata.conversation_context.extracted_entities.length}
                    </div>
                    <div class="matched-entities">
                        ${metadata.conversation_context.extracted_entities.map(entity => `
                            <div class="matched-entity">
                                <div class="entity-name">${Utils.escapeHtml(entity)}</div>
                                <div class="entity-type">Conversation Entity</div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            entitiesMatchTab.innerHTML = entitiesHtml || `
                <div class="empty-state">
                    <div class="empty-state-icon">üéØ</div>
                    <div class="empty-state-text">No entities found in query or conversation.</div>
                </div>
            `;
        }
        
        // Update reasoning tab with processing pipeline info
        const reasoningTab = document.getElementById('reasoningTab');
        if (reasoningTab) {
            let reasoningHtml = '';
            
            // Show query decomposition
            if (metadata.decomposition) {
                reasoningHtml += `
                    <div class="reasoning-section">
                        <div class="reasoning-title">Query Decomposition</div>
                        <div class="reasoning-item">Intent: ${Utils.escapeHtml(metadata.decomposition.intent)}</div>
                        ${metadata.decomposition.sub_queries.length > 0 ? `
                            <div class="reasoning-item">Sub-queries: ${metadata.decomposition.sub_queries.length}</div>
                            <div class="sub-queries">
                                ${metadata.decomposition.sub_queries.map(sq => `
                                    <div class="sub-query">‚Ä¢ ${Utils.escapeHtml(sq)}</div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }
            
            // Show query expansion
            if (metadata.expansion) {
                reasoningHtml += `
                    <div class="reasoning-section">
                        <div class="reasoning-title">Query Expansion</div>
                        ${metadata.expansion.expanded_terms.length > 0 ? `
                            <div class="reasoning-item">Expanded terms: ${metadata.expansion.expanded_terms.join(', ')}</div>
                        ` : ''}
                        ${metadata.expansion.synonyms.length > 0 ? `
                            <div class="reasoning-item">Synonyms: ${metadata.expansion.synonyms.join(', ')}</div>
                        ` : ''}
                        ${metadata.expansion.related_concepts.length > 0 ? `
                            <div class="reasoning-item">Related concepts: ${metadata.expansion.related_concepts.join(', ')}</div>
                        ` : ''}
                    </div>
                `;
            }
            
            // Show conversation context if available
            if (metadata.conversation_context && metadata.conversation_context.original_query) {
                reasoningHtml += `
                    <div class="reasoning-section">
                        <div class="reasoning-title">Conversation Context</div>
                        <div class="reasoning-item">Original query: ${Utils.escapeHtml(metadata.conversation_context.original_query)}</div>
                        ${metadata.conversation_context.expanded_query ? `
                            <div class="reasoning-item">Expanded query: ${Utils.escapeHtml(metadata.conversation_context.expanded_query)}</div>
                        ` : ''}
                        ${metadata.conversation_context.recent_queries_count > 0 ? `
                            <div class="reasoning-item">Recent queries: ${metadata.conversation_context.recent_queries_count}</div>
                        ` : ''}
                    </div>
                `;
            }
            
            reasoningTab.innerHTML = reasoningHtml || `
                <div class="empty-state">
                    <div class="empty-state-icon">ü§î</div>
                    <div class="empty-state-text">No reasoning information available.</div>
                </div>
            `;
        }
    }
    
    function resetThinkingPanel() {
        document.getElementById('contextTab').innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üß†</div>
                <div class="empty-state-text">Retrieved context will appear here when you ask a question.</div>
            </div>
        `;
        
        document.getElementById('entitiesMatchTab').innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üéØ</div>
                <div class="empty-state-text">Matched entities will appear here.</div>
            </div>
        `;
        
        document.getElementById('reasoningTab').innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">ü§î</div>
                <div class="empty-state-text">Reasoning trace will appear here.</div>
            </div>
        `;
    }
    
    function initializeTabs() {
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabGroup = this.closest('.tabs');
                if (!tabGroup) {
                    console.error('Tab group not found for tab:', this);
                    return;
                }
                
                const tabName = this.dataset.tab;
                if (!tabName) {
                    console.error('Tab name not found for tab:', this);
                    return;
                }
                
                // Find the content container - it's the next sibling of the tabs div
                const contentContainer = tabGroup.nextElementSibling;
                if (!contentContainer) {
                    console.error('Content container not found for tab group:', tabGroup);
                    return;
                }
                
                console.log('Tab clicked:', tabName, 'Content container:', contentContainer);
                
                // Update active tab
                tabGroup.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                // Update active content
                contentContainer.querySelectorAll('.tab-pane').forEach(pane => {
                    pane.classList.remove('active');
                });
                
                const targetPane = document.getElementById(tabName + 'Tab');
                if (targetPane) {
                    targetPane.classList.add('active');
                    console.log('Activated tab pane:', targetPane.id);
                } else {
                    console.error('Target pane not found:', tabName + 'Tab');
                }
            });
        });
    }
    
    function setStatus(text, type = 'idle') {
        document.getElementById('statusText').textContent = text;
        const dot = document.getElementById('statusDot');
        dot.className = `status-dot ${type}`;
        appState.setState({ status: text });
    }
    
    async function loadEntities() {
        if (!appState.selectedDocument) {
            showEntityEmptyState();
            return;
        }
        
        try {
            const project = appState.project;
            if (!project) {
                showToast('No project available', 'error');
                return;
            }
            
            // Load entities for the selected document
            const entitiesResponse = await API.get(`/entities/documents/${appState.selectedDocument.id}/entities?per_page=100`);
            const entities = entitiesResponse.entities || [];
            
            renderEntities(entities);
            
            // Also load relationships
            await loadRelationships();
            
            // Update graph tab with statistics
            updateGraphTab(entities);
            
        } catch (error) {
            console.error('Failed to load entities:', error);
            showToast('Failed to load entities', 'error');
            showEntityEmptyState();
        }
    }
    
    async function loadRelationships() {
        if (!appState.selectedDocument) {
            showRelationshipEmptyState();
            return;
        }
        
        try {
            const project = appState.project;
            if (!project) {
                return;
            }
            
            // Load relationships for the selected document
            const relationshipsResponse = await API.get(`/relationships/documents/${appState.selectedDocument.id}?per_page=100`);
            const relationships = relationshipsResponse.relationships || [];
            
            renderRelationships(relationships);
            
        } catch (error) {
            console.error('Failed to load relationships:', error);
            showToast('Failed to load relationships', 'error');
            showRelationshipEmptyState();
        }
    }
    
    function renderEntities(entities) {
        const entitiesTab = document.getElementById('entitiesTab');
        
        if (entities.length === 0) {
            showEntityEmptyState();
            return;
        }
        
        const html = entities.map(entity => `
            <div class="entity-item">
                <div class="entity-info">
                    <div class="entity-name">${Utils.escapeHtml(entity.entity_name)}</div>
                    <div class="entity-type">${entity.entity_type}</div>
                </div>
                <div class="entity-confidence">${(entity.confidence * 100).toFixed(0)}%</div>
            </div>
        `).join('');
        
        entitiesTab.innerHTML = html;
    }
    
    function renderRelationships(relationships) {
        const relationshipsTab = document.getElementById('relationshipsTab');
        
        if (relationships.length === 0) {
            showRelationshipEmptyState();
            return;
        }
        
        const html = relationships.map(rel => `
            <div class="relationship-item">
                <div class="relationship-info">
                    <div class="relationship-source">${Utils.escapeHtml(rel.source_entity?.entity_name || 'Unknown')}</div>
                    <div class="relationship-type">${rel.relationship_type}</div>
                    <div class="relationship-target">${Utils.escapeHtml(rel.target_entity?.entity_name || 'Unknown')}</div>
                </div>
                <div class="relationship-confidence">${(rel.confidence * 100).toFixed(0)}%</div>
            </div>
        `).join('');
        
        relationshipsTab.innerHTML = html;
    }
    
    function showEntityEmptyState() {
        const entitiesTab = document.getElementById('entitiesTab');
        entitiesTab.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üîç</div>
                <div class="empty-state-text">No entities found for this document.</div>
            </div>
        `;
    }
    
    function showRelationshipEmptyState() {
        const relationshipsTab = document.getElementById('relationshipsTab');
        relationshipsTab.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üîó</div>
                <div class="empty-state-text">No relationships found for this document.</div>
            </div>
        `;
    }
    
    function updateGraphTab(entities) {
        const graphTab = document.getElementById('graphTab');
        
        if (!entities || entities.length === 0) {
            graphTab.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">üï∏Ô∏è</div>
                    <div class="empty-state-text">No entities available for graph visualization.</div>
                </div>
            `;
            return;
        }
        
        // Count entities by type
        const entityTypeCounts = {};
        entities.forEach(entity => {
            const type = entity.entity_type;
            entityTypeCounts[type] = (entityTypeCounts[type] || 0) + 1;
        });
        
        const sortedTypes = Object.entries(entityTypeCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10); // Top 10 types
        
        const html = `
            <div class="graph-stats">
                <h4>Knowledge Graph Statistics</h4>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value">${entities.length}</div>
                        <div class="stat-label">Total Entities</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${Object.keys(entityTypeCounts).length}</div>
                        <div class="stat-label">Entity Types</div>
                    </div>
                </div>
                
                <h5>Top Entity Types</h5>
                <div class="entity-types-list">
                    ${sortedTypes.map(([type, count]) => `
                        <div class="entity-type-item">
                            <span class="entity-type-name">${type}</span>
                            <span class="entity-type-count">${count}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
        
        graphTab.innerHTML = html;
    }
    
    async function triggerPipelineProcessing(documentId, fileName) {
        try {
            console.log(`Starting pipeline processing for document: ${fileName}`);
            setStatus('Processing document...', 'processing');
            
            // Start pipeline processing
            const pipelineResponse = await API.post(`/pipeline/documents/${documentId}/process`);
            console.log('Pipeline started:', pipelineResponse);
            
            showToast(`Processing ${fileName}... (${pipelineResponse.execution_id.substring(0, 8)})`, 'info');
            
            // Monitor pipeline progress
            monitorPipelineProgress(pipelineResponse.execution_id, fileName);
            
        } catch (error) {
            console.error('Failed to start pipeline:', error);
            showToast(`Failed to process ${fileName}: ${error.message}`, 'error');
            setStatus('Ready', 'idle');
        }
    }
    
    async function monitorPipelineProgress(executionId, fileName) {
        const maxAttempts = 30;
        let attempts = 0;
        
        const checkProgress = async () => {
            try {
                const status = await API.get(`/pipeline/${executionId}/status`);
                console.log(`Pipeline progress for ${fileName}:`, status.status, status.current_stage);
                
                if (status.status === 'completed') {
                    setStatus('Ready', 'idle');
                    showToast(`‚úÖ ${fileName} processed successfully! Knowledge graph updated.`, 'success');
                    
                    // Refresh documents and knowledge graph if this document is selected
                    await loadDocuments();
                    if (appState.selectedDocument && appState.selectedDocument.id === status.document_id) {
                        await loadEntities();
                    }
                    return;
                }
                
                if (status.status === 'failed') {
                    setStatus('Ready', 'idle');
                    showToast(`‚ùå Failed to process ${fileName}`, 'error');
                    return;
                }
                
                // Still running, check again
                attempts++;
                if (attempts < maxAttempts) {
                    setTimeout(checkProgress, 2000);
                } else {
                    setStatus('Ready', 'idle');
                    showToast(`‚è±Ô∏è Processing ${fileName} is taking longer than expected`, 'warning');
                }
                
            } catch (error) {
                console.error('Error checking pipeline progress:', error);
                setStatus('Ready', 'idle');
            }
        };
        
        // Start monitoring
        setTimeout(checkProgress, 2000);
    }
    
    // Debug function to test thinking panel
    window.testThinkingPanel = function() {
        console.log('Testing thinking panel...');
        const testMetadata = {
            search_optimization: {
                original_results: { total_count: 50, keyword_count: 10, semantic_count: 35, graph_count: 5 },
                reranked_count: 20
            },
            context_items: 5,
            context_tokens: 1200,
            source_count: 3,
            avg_relevance: 0.75,
            decomposition: {
                intent: "information_seeking",
                entities: ["travel", "content creator"],
                sub_queries: ["How to build travel brand", "Content creation strategies"]
            }
        };
        updateThinkingPanel(testMetadata);
    };
    
    // Global functions for document actions
    window.selectDocument = function(docId) {
        // Update selected document in state
        const selectedDoc = appState.documents.find(doc => doc.id === docId);
        appState.setState({ selectedDocument: selectedDoc });
        
        // Update UI to show selected document
        const documentItems = document.querySelectorAll('.document-item');
        if (documentItems) {
            documentItems.forEach(item => {
                item.classList.remove('selected');
            });
        }
        
        const selectedItem = document.querySelector(`[data-id="${docId}"]`);
        if (selectedItem) {
            selectedItem.classList.add('selected');
        }
        
        // Update knowledge graph section title
        const sectionTitle = document.querySelector('.entity-viewer .section-title');
        if (sectionTitle && selectedDoc) {
            sectionTitle.textContent = `Knowledge Graph - ${selectedDoc.name}`;
        }
        
        // Load knowledge graph data for selected document
        loadEntities();
        
        console.log('Selected document:', selectedDoc);
    };
    
    window.previewDocument = function(docId) {
        showToast('Document preview not implemented yet', 'info');
    };
    
    window.deleteDocument = async function(docId) {
        if (!confirm('Are you sure you want to delete this document?')) return;
        
        try {
            await API.delete(`/documents/${docId}`);
            showToast('Document deleted successfully', 'success');
            
            // Clear selection if deleted document was selected
            if (appState.selectedDocument && appState.selectedDocument.id === docId) {
                appState.setState({ selectedDocument: null });
                document.querySelector('.entity-viewer .section-title').textContent = 'Knowledge Graph';
                showEntityEmptyState();
                showRelationshipEmptyState();
            }
            
            await loadDocuments();
        } catch (error) {
            console.error('Delete failed:', error);
            showToast('Failed to delete document', 'error');
        }
    };
});
</script>
{% endblock %}